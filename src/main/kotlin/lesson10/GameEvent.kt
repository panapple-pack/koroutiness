package lesson10

// У нас на данном этапе есть корутины, игровое время, бой, эффекты и баффы
// но само по себе это все набор компонентов. Для них нужен связывающий слой
// Его называют по разному (Event System / Event Bus, Система событий (тригеров))
///////////////////// === ЗАЧЕМ НУЖНЫ СОБЫТИЯ === /////////////////////
// Без системы событий:
// Квесты не знают, что кто то умер или завершил, или вышел из игры
// НПС не знают, что кто то умер
// UI (User Interface) не знает, что какое то состояние было изменено
// Сервер и клиент не знают, что произошло в мире, что с этим делать и как это синхронизировать

// Система событий (System Bus) - это реакция мира на действие игрока(ов)
// Событие само по себе ничего не делает, это просто сообщение, что что-то произошло и дает команду, что делать
// Пример событий:
// Персонаж умер / Квест выполнен / Игрок попал в зону (локацию) / Игрок ударил по другому игроку / Вышел из игры / NPC изменил состояние (торгует/спит)
// ВАЖНО!!! Событие не:
// 1. Не выполняет какую либо логику
// 2. Не знает и не возвращает информации о том, кто на это событие отреагировал или получил
// Грубо говоря: "Эй сервер/клиент только что игрок пнул npc name"

/////////////////// АНАЛОГИЯ ///////////////////
// Игрок убивает моба
// СТАНДАРТНАЯ ИГРОВАЯ ЦЕПОЧКА (НЕПРАВИЛЬНАЯ) !!!!!!
// <Если убили моба> -> проверить квест -> обновить UI -> обновить состояние NPC -> сохранить процесс
// Это жесткая цепочка, которая может прерваться или сорваться, если чтото пошло не так или что то сделано одновременно
//// Правильная система:
// Моб умирает -> событие уведомляет
// Потом, когда событие случилось
// 1. Квест "слушает" событие, и если оно соответствует требованиям квеста -> обновить квест
// 2. UI слушает событие, обновляет информацию о статусе квеста
// 3. Система инвентаря слушает -> дропает из моба заготовленный предмет с шансом
// 4. Лог сервера слушает событие - пишет информацию в консоль

// Есть событие и есть их подписчики (EventListener)
// Событие CharacterDied, его подписчик (EventListener) это NPC и Quest
// Подписчиками мы называем тех, что слушает данное событие

// sealed class - класс с закрытой иерархией классов
// 1. Все возможные типы событий будут перечислены только здесь
// 2. Компилятор котлин будет сразу знать все варианты событий из данного класса

sealed class GameEvent {
    // sealed - базовый тип любого игрового события

    // Событие смерти персонажа
    data class CharacterDied(
        val characterName: String
    ) : GameEvent()
    // :GameEvent() Наследование обязательно для причисления к данной иерархии

    data class EffectApplied(
        val characterName: String,
        val effectName: String
    ) : GameEvent()

    data class QuestCompleted(
        val questId: String
    ) : GameEvent()
}

// sealed - обязателен для графов, событий и тд.
// благодаря ему мы заранее знаем все до единого типы событий (и также знаем, что дополняются они в одном месте)
// Мы не можем создать новый тип события из ниоткуда кроме как в данном sealed
// Защита от ошибок и конфликтов событий, легко дополняется в одном месте и не нарушает логики (безопасность логических операций)